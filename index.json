[{"content":" Software engineer, former architect (as in, buildings). ","date":null,"permalink":"https://leonh.fr/","section":"","summary":"","title":""},{"content":"","date":null,"permalink":"https://leonh.fr/posts/","section":"","summary":"","title":""},{"content":"","date":null,"permalink":"https://leonh.fr/tags/databases/","section":"Tags","summary":"","title":"Databases"},{"content":"","date":null,"permalink":"https://leonh.fr/tags/developer-tools/","section":"Tags","summary":"","title":"Developer Tools"},{"content":"","date":null,"permalink":"https://leonh.fr/tags/go/","section":"Tags","summary":"","title":"Go"},{"content":"Some bugs compile cleanly, pass all tests, and slip through code reviews. I shipped one of those at work: a database transaction that silently leaked operations outside its boundary. I don\u0026rsquo;t like being stressed with a broken prod, so I built a custom linter to catch them at compile time. Here\u0026rsquo;s how.\nThe Bug: Leaking Transactions #Database transactions are essential for data integrity. Operations wrapped in a transaction are expected to display all-or-nothing behavior: either every operation succeeds, or everything rolls back.\nOne pattern for managing transactions is callbacks. This style of transaction is common when using ORMs such as Gorm. However, this approach makes it easier to accidentally bypass transaction boundaries. Operations can leak outside the intended scope, leading to data corruption and race conditions. Let\u0026rsquo;s look at some code.\nAt my current workplace, the Go backend uses a repository pattern with explicit transactions:\nfunc (s *Service) UpdateUser(ctx context.Context, userID string) error { return s.repo.Transaction(ctx, func(tx models.Repo) error { user, err := tx.GetUser(ctx, userID) if err != nil { return err } user.Name = \u0026#34;Updated\u0026#34; return tx.SaveUser(ctx, user) }) } The callback receives tx, a transaction-scoped repository. All database operations inside must use tx to participate in the transaction.\nThis pattern works, but it\u0026rsquo;s easy to mix up the two scopes:\nfunc (s *Service) UpdateUser(ctx context.Context, userID string) error { return s.repo.Transaction(ctx, func(tx models.Repo) error { user, err := s.repo.GetUser(ctx, userID) // Bug: uses s.repo, not tx. if err != nil { return err } user.Name = \u0026#34;Updated\u0026#34; return tx.SaveUser(ctx, user) // Ok: inside the transaction. }) } The GetUser call uses s.repo (the component\u0026rsquo;s field) instead of tx (the transaction callback parameter). This operation executes outside the transaction boundary.\nThis mistake is easy to miss because the code often appears to work correctly. It typically happens when wrapping existing code in a transaction and forgetting to update one reference.\nIt\u0026rsquo;s Hard to Catch #What\u0026rsquo;s more, this bug is insidious and hard to catch. The code compiles without error. Tests pass because they run in isolation with no contention. Failures are unpredictable and usually only happen under load. Worst of all, the failure mode is often silent data corruption, not loud and easy-to-diagnose crashes.\nIt\u0026rsquo;s also easy to miss in code reviews, especially when the bug is nested a few functions deep. AI review tools only caught it when it was obvious, so they were not reliable enough. After some of these slipped through and resulted in me banging my head against the wall long debugging sessions, I decided to find a more efficient way to catch them.\nStatic analysis is well-suited here. The bug is structural, not behavioral. It\u0026rsquo;s all about which variable the code references (s.repo vs tx), not about runtime values. The pattern is detectable from source code alone.\nThat\u0026rsquo;s why I decided to write a linter. While I use them every day, I wasn\u0026rsquo;t exactly sure how they worked nor where to start. However, writing one seemed like an interesting challenge, so I\u0026rsquo;m sharing what I learned.\nThe go/analysis Framework #The current standard for Go linters is the go/analysis framework. It makes static analysis surprisingly accessible. The framework lets you focus on the linter logic while it handles all the complexity of parsing, type-checking, and running analyses.\nThe package provides a standardized structure for building analyzers with the analysis.Analyzer type:\nfunc NewAnalyzer() *analysis.Analyzer { return \u0026amp;analysis.Analyzer{ Name: \u0026#34;transactioncheck\u0026#34;, Doc: \u0026#34;checks that Transaction callbacks use the transaction-scoped repo parameter\u0026#34;, Run: runTransactionCheck, Requires: []*analysis.Analyzer{inspect.Analyzer}, } } The Run field contains a function that executes the analysis on a single package. It receives an *analysis.Pass struct containing everything needed for analysis: parsed AST, type information, and a Reportf method for flagging violations.\nThe Requires field specifies a list of other analyzers this one depends on. Here, we depend on inspect.Analyzer, which provides an optimized AST traversal mechanism.\nFollowing Go convention, where linters typically have a check suffix (like staticcheck or nilcheck), I called mine transactioncheck.\nImplementation Deep Dive # The source code is provided as a standalone repository. Walking the AST #Here\u0026rsquo;s the entry point of the analyzer:\nfunc runTransactionCheck(pass *analysis.Pass) (any, error) { inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector) nodeFilter := []ast.Node{(*ast.CallExpr)(nil)} inspect.Preorder(nodeFilter, func(n ast.Node) { callExpression := n.(*ast.CallExpr) if !isTransactionCall(pass, callExpression) { return } // Analyze the transaction callback... }) return nil, nil } We filter for call expressions (*ast.CallExpr). We want to inspect every function or method call, and nothing else. This avoids visiting every node in the AST. Then, if it\u0026rsquo;s a Transaction call, we analyze its callback for violations.\nIdentifying Transaction Calls #Before we can detect misused repositories, we need to determine whether a call is a transaction call. The implementation of this is specific to each codebase.\nFirst, we need to detect repository interfaces. In our example, we have a unique models.Repo interface. We match it by name (Repo) and package location (example.com/models).\nNow that we can identify repositories, we need to detect transaction calls. In the AST, method calls like repo.DoSomething() are represented as selector expressions (*ast.SelectorExpr), while direct calls like doSomething() are not. We check that the node is a selector expression, the method name is Transaction, and the receiver is a repository interface.\nTracking the Transaction Parameter #When we find a transaction call, we extract the first parameter of the callback. This is the transaction-scoped parameter, tx. We need to verify that all operations within the callback use it, which means tracking it while we traverse the callback\u0026rsquo;s AST.\nWe capture two things:\nthe parameter name (txParameterName) for error messages like \u0026ldquo;should use transaction parameter tx\u0026rdquo;, the type object (txParameterObject) for identity comparison. In Go\u0026rsquo;s type system, two identifiers referring to the same variable share the same types.Object, which we can compare with a simple equality check ==. This allows us to track the transaction parameter without relying on name matching, which would fail anyway if the variable name is shadowed.\nfunc isTransactionParameter( pass *analysis.Pass, expression ast.Expr, txParameterObject types.Object, ) bool { identifier, ok := expression.(*ast.Ident) if !ok { return false } object := pass.TypesInfo.Uses[identifier] if object == nil { object = pass.TypesInfo.Defs[identifier] } return object == txParameterObject } Traversing the Callback #For each transaction callback we find, we traverse its AST to look for violations. We use ast.Inspect to walk every node:\nfunc checkTransactionCallback( pass *analysis.Pass, functionBody *ast.BlockStmt, ) { ast.Inspect(functionBody, func(n ast.Node) bool { callExpr, ok := n.(*ast.CallExpr) if !ok { return true // The node is not a function call, we keep traversing. } if isTransactionCall(pass, callExpr) { return false // Stop traversing: nested transactions have their own scope. } // Check for violations... return true }) } The traversal stops when it encounters a nested transaction. A nested Transaction call creates its own transaction scope with its own tx parameter. Any code inside that nested callback is outside our current analysis scope and will be analyzed separately when we encounter that transaction call.\nDetecting Outer Repository Method Calls #One violation type happens when we call a method on the outer repository instead of the transaction parameter:\ns.repo.Transaction(ctx, func(tx models.Repo) error { user := s.repo.GetUser(ctx, \u0026#34;123\u0026#34;) // Violation: should use tx.GetUser. return tx.SaveUser(ctx, user) }) We detect this by checking if the receiver of a method call is a repository interface that isn\u0026rsquo;t our transaction parameter:\nfunc checkRepoMethodCall( pass *analysis.Pass, selectorExpression *ast.SelectorExpr, txParameterName string, txParameterObject types.Object, ) { receiverType := pass.TypesInfo.TypeOf(selectorExpression.X) if !isRepoInterface(receiverType) { return // Receiver is not a repository interface. } if isTransactionParameter(pass, selectorExpression.X, txParameterObject) { return // Using the transaction parameter is correct. } pass.Reportf( selectorExpression.X.Pos(), \u0026#34;using non-transaction repo; should use %q instead\u0026#34;, txParameterName, ) } Detecting Outer Repositories Passed to Helper Functions #The second violation we want to detect is more subtle: it happens when passing the outer repository to a helper function instead of the transaction parameter.\nfunc (s *Service) CreateUser(ctx context.Context, userID string) error { return s.repo.Transaction(ctx, func(tx models.Repo) error { return helperFunction(ctx, s.repo, userID) // Violation: should pass tx. }) } func helperFunction(ctx context.Context, repo models.Repo, userID string) error { return repo.SaveUser(ctx, \u0026amp;User{ID: userID}) } Here, s.repo is passed as an argument, and the helper uses it for database operations outside the transaction. The detection logic is similar to before: check if any argument is a repository interface that isn\u0026rsquo;t the transaction parameter:\nfunc checkCallArguments( pass *analysis.Pass, callExpression *ast.CallExpr, txParameterName string, txParameterObject types.Object, ) { for _, argument := range callExpression.Args { argumentType := pass.TypesInfo.TypeOf(argument) if !isRepoInterface(argumentType) { continue // Argument is not a repository interface. } if isTransactionParameter(pass, argument, txParameterObject) { continue // Passing the transaction parameter is correct. } pass.Reportf( argument.Pos(), \u0026#34;passing non-transaction repo to function; should pass %q instead\u0026#34;, txParameterName, ) } } Recursive Analysis of Helper Functions #Detecting violations at the call site isn\u0026rsquo;t always enough. Consider a chain of helper functions:\nfunc (s *Service) CreateOrder(ctx context.Context, userID string) error { return s.repo.Transaction(ctx, func(tx models.Repo) error { // Ok: passing the transaction callback parameter. return s.processOrder(ctx, tx, userID) }) } func (s *Service) processOrder(ctx context.Context, repo models.Repo, userID string) error { // Ok: using the repository parameter. user, err := repo.GetUser(ctx, userID) if err != nil { return err } // Ok: passing the transaction callback parameter. return s.finalizeOrder(ctx, repo, user) } func (s *Service) finalizeOrder(ctx context.Context, repo models.Repo, user *User) error { // Bug: uses s.repo instead of the repo parameter. return s.repo.SaveOrder(ctx, \u0026amp;Order{UserID: user.ID}) } Taken separately, none of these functions would be flagged. finalizeOrder is not a violation in isolation. It only becomes a bug when called as part of a transaction. To catch this, we need to recursively analyze helper functions.\nWhen the linter sees s.processOrder(ctx, tx, userID) passing the transaction parameter, it recurses into processOrder, now tracking repo as the transaction parameter. When processOrder calls s.finalizeOrder(ctx, repo, user), the linter recurses again. Finally, inside finalizeOrder, it detects that s.repo.SaveOrder uses s.repo instead of the repo parameter.\nTo prevent infinite loops when helpers call each other, the linter tracks visited functions. This ensures each function is analyzed at most once per transaction.\nTesting with analysistest #The go/analysis framework provides analysistest, which makes testing Analyzers simple and elegant:\nfunc TestAnalyzer(t *testing.T) { testdata := analysistest.TestData() analysistest.Run(t, testdata, NewAnalyzer(), \u0026#34;transactioncheck\u0026#34;) } Test cases then live in testdata/src/transactioncheck and use special // want comments for assertions:\nfunc (s *Service) IncorrectUsage(ctx context.Context) error { return s.repo.Transaction(ctx, func(tx models.Repo) error { _ = s.repo.GetUser( // want \u0026#34;using non-transaction repo; should use \\\u0026#34;tx\\\u0026#34; instead\u0026#34; ctx, \u0026#34;123\u0026#34;, ) return nil }) } func (s *Service) CorrectUsage(ctx context.Context) error { return s.repo.Transaction(ctx, func(tx models.Repo) error { _ = tx.GetUser(ctx, \u0026#34;123\u0026#34;) // No \u0026#34;want\u0026#34; comment, should not report. return nil }) } The test framework verifies that lines with // want comments produce matching diagnostics and that lines without them produce no diagnostics. This catches both false negatives (missed bugs) and false positives (false reports).\nCode in /testdata/src is isolated from the rest of the codebase, so we need to mock dependencies such as the models.Repo interface. The subdirectories below /testdata/src have to mirror the import path.\nRunning the Linter #With go/analysis, running the linter is straightforward. Because we only have a single analyzer, we use the singlechecker package. The main function is as simple as:\nfunc main() { singlechecker.Main(transactioncheck.NewAnalyzer()) } This generates a complete CLI with flags for output format, verbosity, and more.\nIt\u0026rsquo;s possible to run an analyzer as part of golangci-lint (in fact, they only accept linters written with this framework). Since transactioncheck is not generic to all codebases, proposing it as a public linter didn\u0026rsquo;t make sense.\ngolangci-lint also supports private linters, but that would require building a custom binary and configuring every developer\u0026rsquo;s editor to use it. This was not practical.\nFor this reason, a custom linter is best run as a standalone tool. For example, at work we use mise as a task runner, so it\u0026rsquo;s easy to integrate it:\n[tasks.lint] depends_post = \u0026#34;transactioncheck\u0026#34; run = \u0026#39;golangci-lint run -v\u0026#39; [tasks.build-transactioncheck] sources = [\u0026#34;./tools/transactioncheck/**/*.go\u0026#34;] run = \u0026#39;go build -o bin/transactioncheck tools/transactioncheck/cmd/main.go\u0026#39; [tasks.transactioncheck] depends = \u0026#34;build-transactioncheck\u0026#34; run = \u0026#39;bin/transactioncheck ./...\u0026#39; The depends key ensures the linter is built before it runs. The depends_post key runs transactioncheck after golangci-lint.\nFinally, I added the linter to CI. New violations now break the build, preventing these bugs from reaching production.\nYou Should Write Your Own Linter #When I first ran transactioncheck, it found multiple violations across the codebase. These were not hypothetical bugs. Thankfully, none were in services handling financial data, as those get more diligent review, but the risk was real.\nWhat started as frustration with transaction bugs became a two-day project that now protects the entire codebase. The linter runs in seconds, catches a whole class of bugs at compile time, and has required almost no maintenance since.\nIf your team has code patterns that are easy to get wrong, consider building a custom linter!\n","date":"27 January 2026","permalink":"https://leonh.fr/posts/go-transaction-linter/","section":"","summary":"\u003cp\u003eSome bugs compile cleanly, pass all tests, and slip through code reviews. I shipped one of those at work: a database transaction that silently leaked operations outside its boundary. I don\u0026rsquo;t like being stressed with a broken prod, so I built a custom linter to catch them at compile time. Here\u0026rsquo;s how.\u003c/p\u003e","title":"I shipped a transaction bug, so I built a linter"},{"content":"","date":null,"permalink":"https://leonh.fr/tags/static-analysis/","section":"Tags","summary":"","title":"Static Analysis"},{"content":"","date":null,"permalink":"https://leonh.fr/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"https://leonh.fr/tags/ci/","section":"Tags","summary":"","title":"Ci"},{"content":"At work, mock generation was slow: 5 minutes locally, and 15 in CI. That\u0026rsquo;s long enough that I\u0026rsquo;d start something else while waiting and forget to come back. Refusing to accept the harsh realities of life, I wondered if we could do better.\nWe use gomock with go:generate directives scattered across the codebase:\n//go:generate mockgen -destination service_mock.go -package invoice . Service This is package mode. You give it an import path and interfaces, and it generates mocks. Simple enough, right?\nBut package mode works by building the entire package and using reflection to inspect interfaces. When you have a large enough codebase with dozens of mocks, this adds up.\nI discovered that mockgen has another mode: source mode.\n//go:generate mockgen -source service.go -destination service_mock.go -package invoice Instead of building and reflecting, it parses the source file directly and analyzes the AST. No more compilation and no more reflection.\nThe migration was a simple search \u0026amp; replace. When testing locally, mock generation was 3 times faster. When I pushed the PR, I watched the CI job drop from 15 minutes to 3.\nThere\u0026rsquo;s one quirk: source mode mocks every interface in the file. You can\u0026rsquo;t specify just one as with package mode. However, you can use -exclude_interfaces to exclude some:\n//go:generate mockgen -source service.go -destination service_mock.go -package invoice -exclude_interfaces Repository If mock generation is slow for you too, check your mockgen directives. One flag might be all you need.\n","date":"1 November 2025","permalink":"https://leonh.fr/posts/mockgen-source-mode/","section":"","summary":"\u003cp\u003eAt work, mock generation was slow: 5 minutes locally, and 15 in CI. That\u0026rsquo;s long enough that I\u0026rsquo;d start something else while waiting and forget to come back. Refusing to accept the harsh realities of life, I wondered if we could do better.\u003c/p\u003e","title":"One mockgen flag can make your CI 5x faster"},{"content":"","date":null,"permalink":"https://leonh.fr/tags/testing/","section":"Tags","summary":"","title":"Testing"},{"content":"","date":null,"permalink":"https://leonh.fr/tags/bash/","section":"Tags","summary":"","title":"Bash"},{"content":"","date":null,"permalink":"https://leonh.fr/tags/shell/","section":"Tags","summary":"","title":"Shell"},{"content":"Shell scripts are awesome, as we know. Now, we have nice shell scripts that self document. But if you\u0026rsquo;re anything like me, you have lots of them in your ~/bin or wherever you put them. One reason is that each script can do one thing and one thing only. Wouldn\u0026rsquo;t it be nice if we could group different functionalities in the same file?\nSome CLIs already do that with subcommands. Think git add or go get. We\u0026rsquo;re going to check how to simply have subcommands with shell scripts.\nFirst, we put each functionality in its own function. Each function should be prefixed sub_. Of course, we have the documentation at the top and a help function to parse and print the documentation. Note that each function also has a comment.\n#!/bin/bash ### ### my-script — does several things well ### ### Usage: my-script [options] \u0026lt;subcommand\u0026gt; ### ### Options: ### -h,--help: Show this message. ### ### Subcommands: ### help: show this message sub_help() { sed -rn \u0026#39;s/^### ?//p\u0026#39; \u0026#34;$0\u0026#34; } ### foo: do some the foo thing sub_foo() { echo \u0026#34;Running the foo subcommand\u0026#34; } ### bar: do the bar thing, which is related but different to the foo thing sub_bar() { echo \u0026#34;Running the bar subcommand\u0026#34; echo \u0026#34;We can use first argument with \u0026#39;$1\u0026#39;\u0026#34; echo \u0026#34;The second argument is \u0026#39;$2\u0026#39;, and so on\u0026#34; } Then, at the end of the script, we put this piece of magic:\nSCRIPT_NAME=$(basename $0) SUBCOMMAND=$1 case $SUBCOMMAND in \u0026#34;\u0026#34; | \u0026#34;-h\u0026#34; | \u0026#34;--help\u0026#34;) sub_help ;; *) shift sub_${SUBCOMMAND} $@ if [ $? = 127 ]; then echo \u0026#34;Error: \u0026#39;$SUBCOMMAND\u0026#39; is not a known subcommand.\u0026#34; \u0026gt;\u0026amp;2 echo \u0026#34; Run \u0026#39;$SCRIPT_NAME --help\u0026#39; for a list of known subcommands.\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi ;; esac What\u0026rsquo;s happening here? Some notes:\nwe store the name of the script with basename; we use a bash case statement; we check the first argument, the subcommand, if it\u0026rsquo;s one of -h, --help, or empty, we print the help and exit; otherwise (see the *) which is the default case), we: use the shift command to shift positional parameters to the left, so command name which was in $1 is placed at $0 instead, and so on for other arguments; we execute the subcommand function with the repositioned arguments $@; if the subcommand doesn\u0026rsquo;t exist, we print an error message using the script name. Now the cool thing about this is that not only can we add as many subcommands as we like, but the help message also gets updated with the subcommand comments, so the script is still self documenting.\nPrinting the help:\n$ my-script --help my-script — does several things well Usage: my-script [options] \u0026lt;subcommand\u0026gt; Options: -h,--help: Show this message. Subcommands: help: show this message foo: do the foo thing bar: do the bar thing, which is related but different to the foo thing Running the bar subcommand:\n$ my-script bar hello world Running the bar subcommand We can use first argument with \u0026#39;hello\u0026#39; The second argument is \u0026#39;world\u0026#39;, and so on Command that doesn\u0026rsquo;t exist:\n$ my-script hello Error: \u0026#39;hello\u0026#39; is not a known subcommand. Run \u0026#39;my-script --help\u0026#39; for a list of known subcommands. ","date":"1 October 2022","permalink":"https://leonh.fr/posts/shell-script-subcommands/","section":"","summary":"\u003cp\u003eShell scripts are awesome, \n      \n    \u003ca href=\"https://leonh.fr/posts/shell-script-help/\"\u003eas we know\u003c/a\u003e. Now, we have nice shell scripts that self document. But if you\u0026rsquo;re anything like me, you have lots of them in your \u003ccode\u003e~/bin\u003c/code\u003e or wherever you put them. One reason is that each script can do one thing and one thing only. Wouldn\u0026rsquo;t it be nice if we could group different functionalities in the same file?\u003c/p\u003e","title":"Simple shell script subcommands"},{"content":"Shell scripts are awesome. They are so useful to automate repetitive and boring work. The hardest thing about them, though, is documentation. How often have you written one, put it in the bin directory and forgotten all about it? How cool would it be to have a help message for them?\nWe could, of course, implement it with a bunch of echo calls. But there\u0026rsquo;s a neat trick. I originally learned this trick in a blog post by Egor Kovetskiy, but the post seems to be gone. As it was very useful to me, I\u0026rsquo;m putting it out there again.\nAdd your help message as comments at the top of your file, right after the shebang.\n#!/bin/bash ### ### my-script — does one thing well ### ### Usage: ### my-script \u0026lt;input\u0026gt; \u0026lt;output\u0026gt; ### ### Options: ### \u0026lt;input\u0026gt; Input file to read. ### \u0026lt;output\u0026gt; Output file to write. Use \u0026#39;-\u0026#39; for stdout. ### -h Show this message. Next, we need to get this message using sed.\nsed -rn \u0026#39;s/^### ?//p\u0026#39; \u0026#34;$0\u0026#34; What\u0026rsquo;s happening here:\n$0 is the filename of the file that is being executed; -r flag means using extended regular expressions; -n flag prevents sed from echoing each line to the standard output; s stands for substitution of the following pattern; / defines the start and end of the pattern; ^### ? matches a string starting with ### followed by an optional space; // defines the substitution string, here an empty string; p prints the result of the substitution. Now, we just need to call this if -h is passed or no arguments are given.\nif [[ $# == 0 ]] || [[ \u0026#34;$1\u0026#34; == \u0026#34;-h\u0026#34; ]]; then sed -rn \u0026#39;s/^### ?//p\u0026#39; \u0026#34;$0\u0026#34; exit 0 fi Hope it helps!\n","date":"16 February 2022","permalink":"https://leonh.fr/posts/shell-script-help/","section":"","summary":"\u003cp\u003eShell scripts are awesome. They are so useful to automate repetitive and boring work. The hardest thing about them, though, is documentation. How often have you written one, put it in the \u003ccode\u003ebin\u003c/code\u003e directory and forgotten all about it? How cool would it be to have a help message for them?\u003c/p\u003e","title":"Help message for shell scripts"},{"content":" \u0026ldquo;Hello, friend?\u0026rdquo; That\u0026rsquo;s lame. Maybe I should give you a name\u0026hellip; But that\u0026rsquo;s a slippery slope. You\u0026rsquo;re only in my head. We have to remember that\u0026hellip; Shit. It\u0026rsquo;s actually happened. I\u0026rsquo;m talking to an imaginary person.\n\u0026ndash; Mr. Robot S01E01\nThis is the start of yet another developer blog. It\u0026rsquo;s been a long time coming as I have always wanted to have a blog but I have been postponing it.\n","date":"1 January 2021","permalink":"https://leonh.fr/posts/hello-friend/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;Hello, friend?\u0026rdquo; That\u0026rsquo;s lame.\nMaybe I should give you a name\u0026hellip;\nBut that\u0026rsquo;s a slippery slope.\nYou\u0026rsquo;re only in my head.\nWe have to remember that\u0026hellip;\nShit.\nIt\u0026rsquo;s actually happened.\nI\u0026rsquo;m talking to an imaginary person.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u0026ndash; Mr. Robot S01E01\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e","title":"Hello, friend"},{"content":"","date":null,"permalink":"https://leonh.fr/categories/","section":"Categories","summary":"","title":"Categories"}]